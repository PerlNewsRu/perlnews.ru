---
tags: Perl
author: perlnews
title: Выпущен Perl 5.23.1
---

20 июля выпущен второй релиз Perl ветки для разработчиков 5.23. Данный выпуск
состоялся спустя месяц после релиза 5.23.0 и содержит изменения в 8 400 строках
исходного кода.

---

Основные изменения:

- Доработана логика целочисленных смещений. Теперь отрицательное смещение бит
  означает смену направления смещения:

        0x7b >> -4 == 0x7b << 4 == 0x7

  Отрицательное смещение и смещение на число бит больше, чем в машинном слове
  раньше было неопределённым и зависело от C-реализации. Теперь результат
  всегда определён:

        # Типичное поведение _ДО_ Perl 5.23.1
        1 << 67 == 1 << ( 67 % 64 ) == 1 << 3 == 8

        # Теперь смещение на ≥ 64 (для 64-битных систем)
        # означает зануление числа

        1 >> 64 == 0

- Постфиксное разыменование больше не является экспериментальным. Это означает,
  что больше не будут выводится предупреждения при использовании нового
  синтаксиса постфиксного разыменования. Более того, постфиксное разыменование
  теперь работает «из коробки», то есть не требует включения `use feature
  postderef`. Фича `postderef_qq` автоматически подключается при использовании
  `use v5.24`.

        $array_ref->@* # тоже самое, что и @{ $array_ref }

- Удалена экспериментальная возможность авторазыменования (`autoderef`).
  Теперь аргументом для `push`, `pop`, `keys`, `splice`, … не может быть скаляр.

        push $array_ref, $element;      # Ошибка!

        push @$array_ref, $element;     # Ок (совместимо с любым Perl)
        push $array_ref->@*, $element;  # Новый альтернативный способ

- Функции `printf` и `sprintf` теперь позволяют перемещать аргумент точности
  для чисел плавающей запятой:

        printf '%.*2$f', 5, 3;       # выведет 5.000

- Больше не допускается использование непечатных символов ASCII (коды 0-31,
  127) в именах переменных. Вместо непечатного символа можно использовать
  комбинацию из двух символов, начинающейся с символа каретки (циркумфле́кс),
  например `$^]`.

- `alarm()` и `sleep()` теперь выводят предупреждение и возвращают `undef`,
  если аргумент отрицательный. Раньше отрицательный аргумент передавался в
  соответствующую C-функцию, что могло приводить к неожиданным результатам.
